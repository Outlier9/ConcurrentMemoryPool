# ConcurrentMemoryPool
高并发内存池

<h1 id="sEtj9">一、设计架构</h1>
![](https://cdn.nlark.com/yuque/0/2025/png/29309193/1743775236525-5ed5c25f-848b-4c73-9a2f-e78d9f5d76b3.png)

concurrent memory pool主要由以下3个部分构成：

1. **thread cache**：线程缓存是**每个线程独有**的，用于**小于256KB**的内存的分配，线程从这里申请内存**不需要加锁**，每个线程独享一个cache,这也就是这个并发线程池高效的地方。
2. **central cache**：**中心缓存是所有线程所共享**，**thread cache是按需从central cache中获取的对象**。centralcache合适的时机回收thread cache中的对象，避免一个线程占用了太多的内存，而其他线程的内存吃紧，达到内存分配在多个线程中更均衡的按需调度的目的。**central cache是存在竞争的**，所以从这里取内存对象是**需要加锁**，首先这里用的是**桶锁**，其次**只有thread cachel的没有内存对象时才会找central cache**,所以这里**竞争不会很激烈**。
3. **page cache**：页缓存是在**central cache缓存上面的一层缓存**，存储的内存是**以页为单位**存储及分配的central cache没有内存对象时，从page cache分配出一定数量的page,并切割成定长大小的小块内存，分配给central cache。当一个span的几个跨度页的对象都回收以后，page cache会回收central cache满足条件的span 对象，并且合并相邻的页，组成更天的页，缓解内存碎片的问题。

<h1 id="i4eJj">二、ThreadCache</h1>
![](https://cdn.nlark.com/yuque/0/2025/png/29309193/1743775526718-b5d3fffa-6e68-422d-ab73-024f152e5f19.png)

thread cache是哈希桶结构，每个桶是一个按桶位置映射大小的内存块对象的自由链表。每个线程都会有一个thread cache对象，这样每个线程在这里获取对象和释放对象时是无锁的。

<h2 id="hMqxi"> 内存对齐和映射</h2>
![](https://cdn.nlark.com/yuque/0/2025/png/29309193/1743775564150-ae898539-8fd6-411e-bbdf-8e6e77967387.png)

| 区间 | 最小请求 | 对齐粒度 | 最大分配 | 公式计算 |
| --- | --- | --- | --- | --- |
| [1, 128] | 1B | 8 | 8B | (1 + 7) & ~7 = 8 |
| [129, 1024] | 129B | 16 | 144B | (129 + 15) & ~15 = 144 |
| [1025, 8192] | 1025B | 128 | 1152B | (1025 + 127) & ~127 = 1152 |
| [8193, 65536] | 8193B | 1024 | 9216B | (8193 + 1023) & ~1023 = 9216 |
| [65537, 262144] | 65537B | 8192 | 73728B | (65537 + 8191) & ~8191 = 73728 |


<h2 id="QlA1Z">TLS</h2>
线程局部存储(TLS)，是一种变量的存储方法，这个变量在它所在的线程内是全局可访问的，但是不能被其他线程访问到，这样就保持了数据的线程独立性。而熟知的全局变量，是所有线程都可以访问的，这样就不可避免需要锁来控制，增加了控制成本和代码复杂度。

**TLS 是 ThreadCache 的“口袋”**，  
每个线程的裤子上，都缝了一个“口袋”专门放自己用的 ThreadCache，  
你穿的裤子别人看得见，但口袋里的东西别人碰不到。  

| 比喻角色 | 实际含义 |
| --- | --- |
| 👖 每条裤子（线程） | 每个线程 |
| 🧰 裤子口袋（TLS） | 为线程单独准备的存储空间 |
| 🛠 工具（ThreadCache） | 线程专用的内存分配器 |
| 📦 工具仓库（CentralCache） | 所有线程共享资源，访问慢 |
| 🚀 不用去仓库 | 分配内存无需加锁，快如闪电 |


<h1 id="n1vBY">三、CentralCache</h1>
![](https://cdn.nlark.com/yuque/0/2025/png/29309193/1743850921735-4518cf99-2503-4f3d-9bd2-cbf669b89263.png)

central cache也是一哈希桶结构，他的哈希桶的映射关系跟thread cache是一样的。不同的是他的每个哈希桶

位置挂是SpanList链表结构，不过每个映射桶下面的span中的大内存块被按映射关系切成了一个个小内存块对象

挂在span的自由链表中。

<h2 id="ObJAv">申请内存</h2>
1. 当thread cache中没有内存时，就会批量向central cache申请一些内存对象，这里的批量获取对象的数量使用了类似网络tcp协议拥塞控制的慢开始算法；central cache也有一个哈希映射的spanlist,spanlist中挂着span,从span中取出对象给thread cache,这个过程是需要加锁的，不过这里使用的是一个桶锁，尽可能提高效率。
2. central cachel映射的spanlistr中所有span的都没有内存l以后，则需要向page cachel申请一个新的span对象，学到span以后将span管理的内存按大小切好作为自由链表链接到一起。然后从span中取对象给threadcache.
3. entral cache的中挂的span中use_counti记录分配了多少个对象出去，分配一个对象给thread cache,就++use_count

<h2 id="lupKc">Span 设计</h2>
```cpp
struct Span
{
PAGE_ID _pageId = 0; // 大块内存起始页的页号
size_t  _n = 0;      // 页的数量

Span* _next = nullptr;	// 双向链表的结构
Span* _prev = nullptr;

size_t _useCount = 0; // 切好小块内存，被分配给thread cache的计数
void* _freeList = nullptr;  // 切好的小块内存的自由链表
};
```

| 字段名 | 类型 | 含义 | 用途 |
| --- | --- | --- | --- |
| `_pageId` | `PAGE_ID`<br/>（一般是 `size_t`<br/>） | 当前 span 起始页号 | 表示该 span 从哪一页开始，占用页的定位标识 |
| `_n` | `size_t` | 当前 span 包含的连续页数量 | 记录 span 占用了多少页，比如 4 页就是 16KB（如果 1 页 = 4KB） |
| `_next` | `Span*` | 下一块 span 指针 | 用于将多个 span 组成链表，方便管理 |
| `_prev` | `Span*` | 上一块 span 指针 | 与 `_next`<br/> 配合组成双向链表 |
| `_useCount` | `size_t` | 当前 span 被分配给 ThreadCache 的小对象数量 | 用于判断是否可以回收该 span（为 0 表示全部释放） |
| `_freeList` | `void*` | 小对象空闲链表头指针 | 如果该 span 被切割为多个小对象，链表用于存储这些可复用对象 |


<h2 id="SYCfB">单例模式</h2>
 单例模式是一种创建型设计模式，它**确保一个类在程序运行期间只有一个实例**，并提供一个**全局访问点**来获取这个实例。  

| 原因 | 解释 |
| --- | --- |
| ✅ 全局唯一性 | 所有线程的 ThreadCache 都要从 CentralCache 拉数据，不应存在多个 |
| ✅ 线程共享资源 | CentralCache 管理了全局的对象池（freelist），必须一致 |
| ✅ 避免资源冲突 | 多个 CentralCache 会导致数据竞争、内存重复或混乱 |
| ✅ 控制访问 | 通过统一入口 `CentralCache::Instance()`<br/> 控制并发加锁、管理策略 |
| ✅ 生命周期简单 | 程序运行期间存在一份，自动构造、析构，易管理 |


| 优点 | 说明 |
| --- | --- |
| ✅ 保证唯一性 | 内存状态一致，不会重复分配对象池 |
| ✅ 提供全局访问点 | 所有地方都能通过 `CentralCache::Instance()`<br/> 获取 |
| ✅ 控制并发加锁集中化 | 可统一加锁控制访问（如 Fetch/Release） |
| ✅ 生命周期易管理 | 不需要手动 new/delete，一般静态初始化自动创建销毁 |
| ✅ 易于封装 | 可以隐藏内部 freelist、span_list 等数据结构，外部无需关心细节 |


<h2 id="Vz8Iv">获取机制（慢开始反馈调节算法）</h2>
一次 ThreadCache 申请，可以从 CentralCache 中获取多少个

采用慢开始反馈调节算法

「慢开始反馈调节算法」是高性能内存池中**非常经典的动态自适应策略**，在 TCMalloc、jemalloc 等成熟分配器中广泛使用。它的设计目的就是：

🎯 **根据线程实际的内存使用需求，动态调节每次从 CentralCache 拉取的对象数量，既提升性能，又避免资源浪费。**

当一个线程第一次请求某种大小的内存时：

+ 它可能只是偶尔使用这个大小，**不需要一次拉太多**
+ 但如果它频繁使用，**希望能逐渐增加缓存量，减少向 Central 请求的次数**

<h3 id="q6gkZ">固定批量的缺点：</h3>
| 问题 | 举例 |
| --- | --- |
| 拉太多用不完 | 偶尔用一下 64B 对象 → 占用 512 个缓存块，浪费严重 |
| 拉太少频繁拉 | 高频使用对象 → 每次只拿几个 → 频繁加锁，性能差 |


<h3 id="m5VBs">“慢开始”是怎么做的？</h3>
💡 策略核心：

🧠 **每个 size class 的 freelist 都维护一个 **`**MaxSize**`** 字段（上限）**  
第一次从 CentralCache 拉少量，随着使用频率增加，`MaxSize` 自增。

<h3 id="V3aKW">整个流程演示（模拟）</h3>
| 第一次使用 size=64B | batchNum = min(2, 64) = 2 → 向 Central 拉 2 个 |
| --- | --- |
| 用完了 → MaxSize++ | MaxSize = 3，下次就可以拉 3 个 |
| 再用完了 → MaxSize++ | MaxSize = 4，下次就可以拉 4 个 |
| 频繁使用后 → 最多可拉到SizeClass::NumMoveSize(size) 推荐值 | |


 但永远不会超过 `NumMoveSize(size)`，防止无限增长！  

<h3 id="qMuOY"> NumMoveSize(size) 的作用  </h3>
+ 小对象（如 8B）可以一次最多拉 512 个
+ 大对象（如 128KB）只能拉最多 2 个

👉 控制内存总开销 & 对象粒度碎片率

<h3 id="ETKUX">慢启动调节算法的优势</h3>
| 优点 | 说明 |
| --- | --- |
| ✅ 避免初始浪费 | 不确定使用频率时，从少量开始 |
| ✅ 高性能增长 | 如果使用频繁，自动扩大缓存 |
| ✅ 线程局部调节 | 每个线程、每个 size class 独立自调节，互不影响 |
| ✅ 减少锁竞争 | 拉得越多，向 Central 请求越少，线程锁争用更少 |
| ✅ 更贴合实际负载 | 内存使用模式是动态的，算法也是动态适应的 ✅ |


<h1 id="Ed9hB">四、PageCache</h1>
![](https://cdn.nlark.com/yuque/0/2025/png/29309193/1743939996807-e74f8b63-bcc0-4722-b00b-8b9eefe51063.png)

`PageCache` 是整个内存池系统中的最底层核心组件，它管理的是以页（通常 4KB）为单位的大块内存，作用类似于“内存操作系统”或“内部页框分配器”。  

 🎯 `PageCache` 的核心职责是：**管理大块页级内存**，并将其提供给 `CentralCache` 或用于大对象直接分配。  

| 任务 | 说明 |
| --- | --- |
| ✅ 向操作系统申请大块内存 | 通常通过 `malloc`或 `mmap`获取页块（如 128KB） |
| ✅ 管理页的分配与合并 | 页以 `Span`为单位切分、回收、合并 |
| ✅ 构建 pageId → Span 映射表 | 用于定位内存属于哪个 Span（释放时使用） |
| ✅ 支持按页数快速分配 span | 用于大小对齐的页块分配（支持小对象和大对象） |


| 核心原则 | 含义 |
| --- | --- |
| 📦 **批量申请** | 一次向系统申请一大块，减少系统调用开销 |
| ✂️ **分段切割** | 将大页块切成小 span 给 Central 使用 |
| 🔁 **按需合并** | 空闲 span 相邻时尝试合并，减少碎片 |
| 🗺️ **高效定位** | 通过 pageId → span 映射快速反查对象归属 |
| ⏱️ **低频调用** | PageCache 是整个内存池中调用最少的部分（slow path） |



